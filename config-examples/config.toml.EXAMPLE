# ============================================================================
# Pynchy Configuration — EXAMPLE
# ============================================================================
# NOTE: This is a reference example checked into the repo. The live config
# is on pynchy-server (reachable via Tailscale):
#   ssh pynchy-server cat ~/src/PERSONAL/pynchy/config.toml
#
# Copy this file to config.toml and configure for your setup:
#   cp config-examples/config.toml.EXAMPLE config.toml
#
# Most settings have sensible defaults and can be omitted.
# Environment variables override TOML values using __ as the nested delimiter:
#   AGENT__NAME=mybot  →  [agent] name = "mybot"
# ============================================================================

# ─────────────────────────────────────────────────────────────────────────────
# Agent Configuration
# ─────────────────────────────────────────────────────────────────────────────

[agent]
# Name of the assistant (used in trigger detection and message attribution)
# name = "pynchy"

# Trigger aliases (used in addition to agent name for @mentions)
# trigger_aliases = ["ghost"]

# Agent core: "claude" (default) or "openai"
# core = "claude"

# ─────────────────────────────────────────────────────────────────────────────
# API Credentials
# ─────────────────────────────────────────────────────────────────────────────
# Secrets (API keys, tokens, passwords) belong in .env, not here.
# See config-examples/.env.EXAMPLE for the template.
#
# For Claude Code OAuth, run `claude setup-token` to generate a long-lived
# token (~1 year). Add it to .env as CLAUDE_OAUTH_TOKEN and reference it in
# litellm_config.yaml via os.environ/CLAUDE_OAUTH_TOKEN.

# ─────────────────────────────────────────────────────────────────────────────
# Container Configuration
# ─────────────────────────────────────────────────────────────────────────────

[container]
# Container image name (built via ./container/build.sh)
# image = "pynchy-agent:latest"

# Container timeout in milliseconds (30 minutes default)
# timeout_ms = 1800000

# Maximum container output size in bytes (10MB default)
# max_output_size = 10485760

# Idle timeout in milliseconds (30 minutes default)
# idle_timeout_ms = 1800000

# Maximum concurrent agent containers
# max_concurrent = 5

# Override container runtime detection (usually auto-detected)
# Options: "docker" (built-in), "apple" (requires Apple runtime plugin)
# runtime = "docker"

# ─────────────────────────────────────────────────────────────────────────────
# Server Configuration
# ─────────────────────────────────────────────────────────────────────────────

[server]
# HTTP server port for TUI and deploy endpoint
# port = 8484

# ─────────────────────────────────────────────────────────────────────────────
# Gateway Configuration (LiteLLM)
# ─────────────────────────────────────────────────────────────────────────────
# LLM API gateway provides credential isolation for containers.
# Two modes: LiteLLM (recommended) or builtin (simple single-key proxy).

[gateway]
# Path to LiteLLM config file (enables LiteLLM mode)
# API keys and OAuth tokens are referenced via os.environ/ in the YAML
# and set in .env — pynchy forwards them into the LiteLLM container.
# See config-examples/litellm_config.yaml.EXAMPLE.
# If not set, uses builtin mode with credentials from [secrets].
# litellm_config = "litellm_config.yaml"

# Gateway port (set to 4000 when using LiteLLM mode)
# port = 4000

# LiteLLM master key and UI credentials → set in .env (see .env.EXAMPLE):
#   GATEWAY__MASTER_KEY, GATEWAY__UI_PASSWORD

# LiteLLM Docker images (usually keep defaults)
# litellm_image = "ghcr.io/berriai/litellm:main-latest"
# postgres_image = "postgres:17-alpine"

# ─────────────────────────────────────────────────────────────────────────────
# Scheduler & Intervals
# ─────────────────────────────────────────────────────────────────────────────

[scheduler]
# Poll interval for scheduled tasks (seconds)
# poll_interval = 60.0

# Timezone for scheduled tasks (auto-detected from system if empty)
# timezone = "America/New_York"

[intervals]
# Message polling interval (seconds)
# message_poll = 2.0

# IPC file polling interval (seconds)
# ipc_poll = 1.0

# Host cron jobs (runs shell commands directly on host, no LLM/container loop)
# [cron_jobs.rebuild_container]
# schedule = "0 5 * * *"
# command = "./container/build.sh"
# cwd = "."
# timeout_seconds = 1200
# enabled = true

# ─────────────────────────────────────────────────────────────────────────────
# Queue Configuration
# ─────────────────────────────────────────────────────────────────────────────

[queue]
# max_retries = 5
# base_retry_seconds = 5.0

# ─────────────────────────────────────────────────────────────────────────────
# Command Center
# ─────────────────────────────────────────────────────────────────────────────
# The command center is the dedicated, pynchy-managed connection used for
# auto-creating chats (when needed). Set to "tui" for local-only mode.

[command_center]
# connection = "connection.slack.synapse"

# ─────────────────────────────────────────────────────────────────────────────
# Connections
# ─────────────────────────────────────────────────────────────────────────────
# Define which external connections pynchy is allowed to use.

# [connection.slack.synapse]
# bot_token_env = "SLACK__BOT_TOKEN"
# app_token_env = "SLACK__APP_TOKEN"
#
# [connection.slack.synapse.chat.admin-1]
# # Optional per-chat security overrides:
# # [connection.slack.synapse.chat.admin-1.security]
# # access = "readwrite"
# # trigger = "mention"

# ─────────────────────────────────────────────────────────────────────────────
# Plugin Overrides
# ─────────────────────────────────────────────────────────────────────────────
# Built-in plugins are auto-loaded from the monorepo. Use [plugins.<key>] to
# disable a specific built-in plugin:
#
# [plugins.whatsapp]
# enabled = false

# ─────────────────────────────────────────────────────────────────────────────
# Workspace Defaults
# ─────────────────────────────────────────────────────────────────────────────
# Defaults applied to sandboxes that don't override these fields.

[workspace_defaults]
# context_mode = "group"
# access = "readwrite"   # "read", "write", "readwrite"
# mode = "agent"         # "agent" or "chat"
# trust = true
# trigger = "mention"    # "mention" or "always"
# allowed_users = ["owner"]  # user IDs, group refs, or "*"

# ─────────────────────────────────────────────────────────────────────────────
# Sandboxes
# ─────────────────────────────────────────────────────────────────────────────
# Each [sandbox.<folder_name>] defines a sandbox. The folder name matches
# the directory under groups/.

# [sandbox.admin-1]
# chat = "connection.slack.synapse.chat.admin-1"
# is_admin = true
# trigger = "always"
# repo_access = "owner/repo"  # GitHub slug from [repos.*]; grants /workspace/project mount

# [sandbox.admin-2]
# chat = "connection.slack.synapse.chat.admin-2"
# is_admin = true
# trigger = "always"
# repo_access = "owner/repo"

# Example workspace with Google MCP (dot-syntax instance names):
# [sandbox.anyscale-1]
# chat = "connection.slack.synapse.chat.anyscale-1"
# mcp_servers = ["gdrive.anyscale", "gcal.anyscale"]

# Example workspace with MCP access and per-MCP kwargs:
# [sandbox.research]
# chat = "connection.slack.synapse.chat.research"
# mcp_servers = ["dev-tools", "remote-api"]   # groups + individual names, set-unioned
#
# [sandbox.research.mcp.playwright]
# presets = ["dev-research"]                   # expands + merges with explicit values
# allowed-origins = "internal.example.com"     # merged with preset domains

# Example workspace with Slack MCP (references a named server entry):
# [sandbox.acme-1]
# chat = "connection.slack.synapse.chat.acme-1"
# mcp_servers = ["slack_mcp_acme"]

# Example admin workspace with unrestricted MCP access:
# [sandbox.admin]
# chat = "connection.slack.synapse.chat.admin"
# is_admin = true
# mcp_servers = ["all"]
# # no [mcp.playwright] section → no --allowed-origins → unrestricted

# Plugins can provide additional managed sandboxes automatically
# (for example, the `code-improver` periodic agent for pynchy core).

# ─────────────────────────────────────────────────────────────────────────────
# Command Words (magic commands)
# ─────────────────────────────────────────────────────────────────────────────
# Customize the words that trigger special commands.

# [commands.reset]
# verbs = ["reset", "restart", "clear", "new", "wipe"]
# nouns = ["context", "session", "chat", "conversation"]
# aliases = ["boom", "c"]

# [commands.end_session]
# verbs = ["end", "stop", "close", "finish"]
# nouns = ["session"]
# aliases = ["done", "bye", "goodbye", "cya"]

# [commands.redeploy]
# aliases = ["r"]
# verbs = ["redeploy", "deploy"]

# ─────────────────────────────────────────────────────────────────────────────
# Slack Channel (built-in plugin)
# ─────────────────────────────────────────────────────────────────────────────
# Connects to Slack via Socket Mode. Each Slack channel/DM maps to a pynchy
# workspace with JID "slack:<CHANNEL_ID>". Activates when tokens are set.
#
# Gotcha: Auto-created workspace channels won't appear in your Slack sidebar
# automatically. Search for the channel name in Slack and join it manually.

# Slack tokens → set in .env (see .env.EXAMPLE):
#   SLACK__BOT_TOKEN, SLACK__APP_TOKEN

# ─────────────────────────────────────────────────────────────────────────────
# CalDAV (Calendar)
# ─────────────────────────────────────────────────────────────────────────────
# Built-in host-side plugin. Connects to CalDAV servers (Nextcloud, etc.)
# and exposes list_calendars, list_calendar, create_event, delete_event tools.
# Multiple servers with separate credentials are supported. Calendar names
# are auto-discovered from each server.
#
# Agents reference calendars as "server/calendar_name" or just "calendar_name"
# (resolved against the default server). "primary" maps to default_calendar.

# [caldav]
# default_server = "work"  # which server when no prefix given

# [caldav.servers.work]
# url = "https://work.nextcloud.com/remote.php/dav/"
# username = "user@work.com"
# password = "work-app-password"
# default_calendar = "meetings"    # optional: what "primary" resolves to
# allow = ["meetings", "standup"]  # optional: only expose these calendars
# ignore = ["trash"]               # optional: hide these (ignored if allow is set)

# [caldav.servers.personal]
# url = "https://personal.nextcloud.com/remote.php/dav/"
# username = "me@example.com"
# password = "personal-app-password"
# ignore = ["contact_birthdays"]   # hide auto-generated calendars

# ─────────────────────────────────────────────────────────────────────────────
# Chrome Profiles
# ─────────────────────────────────────────────────────────────────────────────
# Generic list of profile names. Any MCP server can attach to a chrome profile.
# Each profile maps to a host directory at data/chrome-profiles/{name}/.
# Auth artifacts (OAuth keys, tokens) are stored there and auto-mounted into
# containers that reference the profile.

# chrome_profiles = ["anyscale", "work"]

# ─────────────────────────────────────────────────────────────────────────────
# MCP Server Definitions
# ─────────────────────────────────────────────────────────────────────────────
# Define MCP servers that agents can access. Docker-based MCPs start on-demand
# and stop after idle_timeout. URL MCPs are always available.
# Requires LiteLLM gateway mode (see [gateway] above).
#
# Google services (gdrive, gcal) — base specs are provided by the built-in
# GoogleMcpPlugin. Declare instances with chrome_profile attachment:
#
# [mcp_servers.gdrive.anyscale]
# chrome_profile = "anyscale"
#
# [mcp_servers.gdrive.work]
# chrome_profile = "work"
#
# [mcp_servers.gcal.anyscale]
# chrome_profile = "anyscale"
#
# Each instance is 2 lines. The plugin provides everything else (Docker image,
# port, transport, Dockerfile). Ports auto-assign from the base. Volume
# auto-mounts from the chrome_profile.
#
# The agent sees tools as mcp__gdrive_anyscale__search (dots → underscores).

# Docker-based MCP (container managed by pynchy):
# [mcp_servers.playwright]
# type = "docker"
# image = "mcp/playwright:latest"
# args = ["--headless", "--port", "8931", "--host", "0.0.0.0"]
# port = 8931
# transport = "sse"
# idle_timeout = 600          # seconds; 0 = never stop
# env = { DISPLAY = ":99" }                            # static env vars
# env_forward = ["MY_SECRET"]                           # forward host vars (identity mapping)
# env_forward = { CONTAINER_VAR = "HOST_VAR" }          # or explicit mapping (container ← host)

# Slack MCP (read-only Slack access via browser tokens):
# One entry per Slack workspace — each gets its own container and tokens.
# [mcp_servers.slack_mcp_acme]
# type = "docker"
# image = "ghcr.io/korotovsky/slack-mcp-server:latest"
# port = 8080
# transport = "http"
# env = { SLACK_MCP_HOST = "0.0.0.0", SLACK_MCP_PORT = "8080" }
# env_forward = { SLACK_MCP_XOXC_TOKEN = "SLACK_XOXC_ACME", SLACK_MCP_XOXD_TOKEN = "SLACK_XOXD_ACME" }

# Remote URL-based MCP:
# [mcp_servers.remote-api]
# type = "url"
# url = "https://api.example.com/mcp"
# transport = "streamable_http"
# auth_value_env = "SOME_API_KEY"    # env var name (never inline secrets)

# Host script MCP (subprocess managed by pynchy):
# [mcp_servers.my_custom_tool]
# type = "script"
# command = "uv"
# args = ["run", "scripts/my-tool.py"]
# port = 8080
# transport = "streamable_http"
# idle_timeout = 600

# ─────────────────────────────────────────────────────────────────────────────
# MCP Groups — named sets of servers for convenience
# ─────────────────────────────────────────────────────────────────────────────

# [mcp_groups]
# dev-tools = ["playwright", "github-mcp"]
# social = ["twitter-mcp", "linkedin-mcp"]
# google_anyscale = ["gdrive.anyscale", "gcal.anyscale"]
# "all" is built-in — refers to every defined mcp_server

# ─────────────────────────────────────────────────────────────────────────────
# MCP Presets — reusable kwarg bundles (resolved at config load time)
# ─────────────────────────────────────────────────────────────────────────────

# [mcp_presets.dev-research]
# allowed-origins = "github.com;stackoverflow.com;docs.python.org;pypi.org"

# [mcp_presets.social-media]
# allowed-origins = "twitter.com;x.com;reddit.com;linkedin.com"

# ─────────────────────────────────────────────────────────────────────────────
# Security
# ─────────────────────────────────────────────────────────────────────────────
# Default blocked patterns for mount security. These are merged with patterns
# from the mount-allowlist.toml file.

# [security]
# blocked_patterns = [".ssh", ".gnupg", ".gpg", ".aws", ...]

# ─────────────────────────────────────────────────────────────────────────────
# Directives (System Prompt Extensions)
# ─────────────────────────────────────────────────────────────────────────────
# Directives inject markdown content into agent system prompts. Each directive
# has a file (relative to project root) and a scope that controls which
# sandboxes receive it.
#
# Scope values:
#   "all"              → matches every sandbox
#   "folder-name"      → matches a specific sandbox folder
#   "owner/repo"       → matches sandboxes whose repo_access equals this slug
#   ["a", "b"]         → union of multiple scopes
#
# Directives are sorted by key name and concatenated with "---" separators.
# Files ending in .EXAMPLE are automatically ignored.

# [directives.base]
# file = "directives/base.md"
# scope = "all"

# [directives.idle-escape]
# file = "directives/idle-escape.md"
# scope = "all"

# [directives.admin-ops]
# file = "directives/admin-ops.md"
# scope = ["admin-1", "admin-2"]

# [directives.pynchy-dev]
# file = "directives/pynchy-dev.md"
# scope = "crypdick/pynchy"
