#!/usr/bin/env python3
"""Generate container plugin requirements from config.toml plugins."""

from __future__ import annotations

import argparse
import tomllib
from pathlib import Path


def normalize_repo_url(repo: str) -> str:
    value = repo.strip()
    if "://" in value or value.startswith("git@"):
        return value
    if value.count("/") == 1:
        return f"https://github.com/{value}.git"
    return value


def _resolve_config_path(config_arg: str, output_path: Path) -> Path:
    raw = Path(config_arg)
    if raw.is_absolute():
        return raw

    cwd_candidate = (Path.cwd() / raw).resolve()
    if cwd_candidate.exists():
        return cwd_candidate

    output_abs = output_path if output_path.is_absolute() else (Path.cwd() / output_path).resolve()
    repo_root = output_abs.parent.parent if output_abs.parent.name == "container" else Path.cwd()
    return (repo_root / raw).resolve()


def _to_git_requirement(repo: str, ref: str) -> str:
    url = normalize_repo_url(repo)
    if url.startswith("git@github.com:"):
        url = "ssh://git@" + url[len("git@") :].replace(":", "/", 1)
    if (
        not url.startswith("http://")
        and not url.startswith("https://")
        and not url.startswith("ssh://")
    ):
        url = "https://" + url
    # Omit "name @" prefix â€” uv infers the package name from metadata.
    # Using the config key as the name breaks when it differs from the
    # package's own metadata name (e.g. "whatsapp" vs "pynchy-plugin-whatsapp").
    return f"git+{url}@{ref}"


def generate_requirements(output_path: Path, config_path: Path) -> int:
    lines: list[str] = []
    if config_path.exists():
        data = tomllib.loads(config_path.read_text())
        plugins = data.get("plugins", {})
        if isinstance(plugins, dict):
            for _plugin_name, plugin_cfg in plugins.items():
                if not isinstance(plugin_cfg, dict):
                    continue
                if plugin_cfg.get("enabled", True) is False:
                    continue
                repo = plugin_cfg.get("repo")
                if not isinstance(repo, str) or not repo.strip():
                    continue
                ref = plugin_cfg.get("ref", "main")
                if not isinstance(ref, str) or not ref.strip():
                    ref = "main"
                lines.append(_to_git_requirement(repo, ref))
    else:
        print(f"Config not found at {config_path}; writing empty plugin requirements file")

    header = [
        "# Auto-generated by container/scripts/generate_plugin_requirements.py",
        "# Contains config-managed pynchy plugins to install into container image.",
    ]
    content = "\n".join(header + [""] + lines + [""])
    output_path.write_text(content)

    print(f"Wrote {len(lines)} plugin requirement(s) to {output_path}")
    return 0


def main() -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--output",
        default="container/requirements-plugins.txt",
        help="Path to write requirements file",
    )
    parser.add_argument(
        "--config",
        default="config.toml",
        help="Path to config.toml containing [plugins.*] entries",
    )
    args = parser.parse_args()
    output_path = Path(args.output)
    config_path = _resolve_config_path(args.config, output_path)
    return generate_requirements(output_path, config_path)


if __name__ == "__main__":
    raise SystemExit(main())
