#!/usr/bin/env python3
"""Generate container plugin requirements from config.toml plugins."""

from __future__ import annotations

import argparse
import tomllib
from pathlib import Path


def normalize_repo_url(repo: str) -> str:
    value = repo.strip()
    if "://" in value or value.startswith("git@"):
        return value
    if value.count("/") == 1:
        return f"https://github.com/{value}.git"
    return value


def _config_path_from_output(output_path: Path) -> Path:
    repo_root = output_path.parents[1] if output_path.is_absolute() else Path.cwd().parent
    return repo_root / "config.toml"


def _to_git_requirement(name: str, repo: str, ref: str) -> str:
    url = normalize_repo_url(repo)
    if url.startswith("git@github.com:"):
        url = "ssh://git@" + url[len("git@") :].replace(":", "/", 1)
    if (
        not url.startswith("http://")
        and not url.startswith("https://")
        and not url.startswith("ssh://")
    ):
        url = "https://" + url
    return f"{name} @ git+{url}@{ref}"


def generate_requirements(output_path: Path, config_path: Path) -> int:
    lines: list[str] = []
    if config_path.exists():
        data = tomllib.loads(config_path.read_text())
        plugins = data.get("plugins", {})
        if isinstance(plugins, dict):
            for plugin_name, plugin_cfg in plugins.items():
                if not isinstance(plugin_cfg, dict):
                    continue
                if plugin_cfg.get("enabled", True) is False:
                    continue
                repo = plugin_cfg.get("repo")
                if not isinstance(repo, str) or not repo.strip():
                    continue
                ref = plugin_cfg.get("ref", "main")
                if not isinstance(ref, str) or not ref.strip():
                    ref = "main"
                lines.append(_to_git_requirement(str(plugin_name), repo, ref))
    else:
        print(f"Config not found at {config_path}; writing empty plugin requirements file")

    header = [
        "# Auto-generated by container/scripts/generate_plugin_requirements.py",
        "# Contains config-managed pynchy plugins to install into container image.",
    ]
    content = "\n".join(header + [""] + lines + [""])
    output_path.write_text(content)

    print(f"Wrote {len(lines)} plugin requirement(s) to {output_path}")
    return 0


def main() -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--output",
        default="container/requirements-plugins.txt",
        help="Path to write requirements file",
    )
    parser.add_argument(
        "--config",
        default="config.toml",
        help="Path to config.toml containing [plugins.*] entries",
    )
    args = parser.parse_args()
    output_path = Path(args.output)
    config_path = Path(args.config)
    if not config_path.is_absolute():
        config_path = _config_path_from_output(output_path)
    return generate_requirements(output_path, config_path)


if __name__ == "__main__":
    raise SystemExit(main())
